import os
import subprocess
import time
from pathlib import Path
from datetime import datetime

# ==========================================
# Configuration
# ==========================================
PROJECT_ROOT = Path("/app")
OUTPUT_DIR = PROJECT_ROOT / "data" / "raw_traces"

# Paths to binaries (Added HPGMG and CoSP2)
BINARIES = {
    "lulesh": PROJECT_ROOT / "extern/traffic_gen/src/LULESH/build/lulesh2.0",
    "comd": PROJECT_ROOT / "extern/traffic_gen/src/CoMD/src-mpi/CoMD-mpi",
    "hpgmg": PROJECT_ROOT / "extern/traffic_gen/src/hpgmg/build/bin/hpgmg-fv",
    # CoSP2 binary location depends on build, usually in src-mpi
    "cosp2": PROJECT_ROOT / "extern/traffic_gen/src/CoSP2/CoSP2-parallel", 
}

TRACER_LIB = PROJECT_ROOT / "extern/traffic_gen/src/libmpitrace.so"

def get_experiments():
    experiments = []
    
    # === SC26 Comprehensive Suite ===
    # Scale: 64 ranks (Standard) and 128 ranks (Large)
    # Warning: 128 ranks on M4 will be slow but will produce beautiful matrices.
    
    rank_configs = [128] 
    # Uncomment 128 if you have time (might take 5-10 mins to run)
    # rank_configs = [64, 128] 

    for np in rank_configs:
        # Calculate cubic dimension for mesh apps (cbrt(64)=4, cbrt(128)~5)
        # Note: 128 is not a perfect cube, so we stick to 64 for cubic apps strictly
        # Or we use 125 (5x5x5) for cubic apps if we want >100.
        
        # 1. LULESH (Stencil / Nearest Neighbor)
        # Requires cubic number of ranks usually. 
        # We stick to perfect cubes: 64 (4^3). If you want 125, set np=125.
        if abs(round(np**(1/3)) ** 3 - np) < 0.1: # If perfect cube
            cube_side = int(np**(1/3))
            experiments.append({
                "app": "lulesh",
                "args": ["-s", "15", "-i", "15"], # Size 15, 15 iterations
                "np": np,
                "name": f"lulesh_n{np}_cube"
            })

        # 2. CoMD (Molecular Dynamics / Spatial Decomposition)
        # Also prefers cubic or near-cubic
        if np == 64:
            experiments.append({
                "app": "comd",
                "args": ["-i", "4", "-j", "4", "-k", "4", "-x", "40", "-y", "40", "-z", "40"],
                "np": 64,
                "name": "comd_n64_dense"
            })
        
        # 3. HPGMG (Multigrid / Hierarchical)
        # HPGMG requires np to be of form 8^k? Or just flexible.
        # Let's try running it with 4 boxes per rank
        experiments.append({
            "app": "hpgmg",
            # 5 is log2 of box size. 
            "args": ["5", "1"], 
            "np": np,
            "name": f"hpgmg_n{np}_fv"
        })

        # 4. CoSP2 (Sparse Linear Algebra / Graph-like)
        # Very different traffic pattern (irregular)
        # Needs input files usually, usually generates internal graph if no input
        # Check if binary exists first
        if (PROJECT_ROOT / "extern/traffic_gen/src/CoSP2/CoSP2-parallel").exists():
             experiments.append({
                "app": "cosp2",
                # CoSP2 args: [m] [k] [alpha] ... hard to tune without docs.
                # Assuming default no-args runs a small test
                "args": [], 
                "np": np,
                "name": f"cosp2_n{np}_sparse"
            })

    return experiments

def run_experiment(exp):
    app_name = exp["app"]
    binary_path = BINARIES.get(app_name)
    
    if not binary_path or not binary_path.exists():
        print(f"[Skip] Binary not found for {app_name}")
        return

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    run_dir = OUTPUT_DIR / f"{exp['name']}_{timestamp}"
    run_dir.mkdir(parents=True, exist_ok=True)

    print(f"--> Running {exp['name']} (np={exp['np']})...")

    cmd = [
        "mpirun",
        "--allow-run-as-root",
        "--oversubscribe", # CRITICAL for high ranks on Mac
        "-np", str(exp["np"]),
        "-x", f"LD_PRELOAD={TRACER_LIB}",
        str(binary_path)
    ] + exp["args"]

    try:
        with open(run_dir / "stdout.log", "w") as f_out, open(run_dir / "stderr.log", "w") as f_err:
            start_time = time.time()
            # Increase timeout for heavy runs (e.g., 300 seconds)
            subprocess.run(cmd, stdout=f_out, stderr=f_err, check=True, cwd=run_dir, timeout=300)
            duration = time.time() - start_time
            
        print(f"    ✅ Done in {duration:.2f}s")
        
    except subprocess.CalledProcessError as e:
        print(f"    ❌ FAILED! Exit code: {e.returncode} (Check {run_dir}/stderr.log)")
    except subprocess.TimeoutExpired:
        print(f"    ⏳ TIMEOUT after 300s!")

if __name__ == "__main__":
    if not TRACER_LIB.exists():
        print("Error: Tracer library missing. Run ./build_all.sh")
        exit(1)

    experiments = get_experiments()
    print(f"Planned {len(experiments)} massive experiments.")
    
    total_start = time.time()
    for exp in experiments:
        run_experiment(exp)
    
    print(f"\nAll experiments finished in {time.time() - total_start:.2f}s")